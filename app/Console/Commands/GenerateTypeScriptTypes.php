<?php

declare(strict_types=1);

namespace App\Console\Commands;

use Exception;
use Illuminate\Console\Command;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\HasOne;
use Illuminate\Database\Eloquent\Relations\MorphMany;
use Illuminate\Database\Eloquent\Relations\MorphOne;
use Illuminate\Support\Facades\File;
use ReflectionClass;
use ReflectionMethod;
use ReflectionNamedType;

final class GenerateTypeScriptTypes extends Command
{
    protected $signature = 'generate:ts-types 
        {--models : Only generate model types}
        {--enums : Only generate enum types}
        {--output= : Custom output directory (default: resources/js/types)}';

    protected $description = 'Generate TypeScript definitions from Eloquent models and Enums by parsing migrations';

    /** @var array<int, string> */
    private array $processedModels = [];

    /** @var array<string, array<string, array{name: string, type: string, nullable: bool}>> */
    private array $migrationCache = [];

    public function handle(): int
    {
        $generateModels = $this->option('models') || (! $this->option('enums'));
        $generateEnums = $this->option('enums') || (! $this->option('models'));

        $outputDir = $this->option('output') ?? resource_path('js/types');
        File::ensureDirectoryExists($outputDir);

        $enumCount = 0;
        $modelCount = 0;

        if ($generateEnums) {
            $enumPath = $outputDir.DIRECTORY_SEPARATOR.'enums.d.ts';
            File::put($enumPath, $this->generateFileHeader().$this->generateEnumTypes());

            $enumCount = count($this->getEnums(app_path('Enums')));
            $this->components->twoColumnDetail('Enums', $enumCount.' → '.$enumPath);
        }

        if ($generateModels) {
            $modelPath = $outputDir.DIRECTORY_SEPARATOR.'models.d.ts';
            File::put($modelPath, $this->generateFileHeader().$this->generateModelTypes());

            $modelCount = count($this->getModels(app_path('Models')));
            $this->components->twoColumnDetail('Models', $modelCount.' → '.$modelPath);
        }

        $this->components->info('TypeScript definitions generated successfully!');

        return Command::SUCCESS;
    }

    private function generateFileHeader(): string
    {
        $output = "/**\n";
        $output .= " * Auto-generated TypeScript definitions\n";
        $output .= " * \n";
        $output .= " * DO NOT EDIT THIS FILE MANUALLY!\n";
        $output .= " * \n";
        $output .= ' * Generated at: '.now()->toDateTimeString()."\n";
        $output .= " * Run `php artisan generate:ts-types` to regenerate\n";

        return $output." */\n\n";
    }

    private function generateEnumTypes(): string
    {
        $output = '';

        $enums = $this->getEnums(app_path('Enums'));

        foreach ($enums as $enumClass) {
            $reflection = new ReflectionClass($enumClass);
            $enumName = $reflection->getShortName();

            // For nested namespaces like App\Enums\RBAC\Role, keep the parent namespace
            // Results in: Role (flat) or RBACRole (nested)
            $namespace = str_replace(['App\\Enums\\', 'App\\Enums'], '', $reflection->getNamespaceName());
            $fullName = $namespace !== '' && $namespace !== '0' ? str_replace('\\', '', $namespace).$enumName : $enumName;

            $cases = $enumClass::cases();

            if (empty($cases)) {
                continue;
            }

            // Get the backing type
            $backingType = $this->getEnumBackingType($enumClass);

            // Generate union type
            $values = array_map(fn ($case): string => $this->formatEnumValue($case->value, $backingType), $cases);
            $output .= "export type {$fullName} = ".implode(' | ', $values).";\n\n";
        }

        return $output;
    }

    private function generateModelTypes(): string
    {
        $output = '';

        $models = $this->getModels(app_path('Models'));
        $this->loadMigrations();

        // Collect all enum types used in models
        $usedEnums = $this->collectUsedEnums($models);

        // Add imports for enum types
        if ($usedEnums !== []) {
            $output .= 'import type {'."\n";
            $output .= '  '.implode(",\n  ", $usedEnums)."\n";
            $output .= "} from './enums';\n\n";
        }

        foreach ($models as $modelClass) {
            try {
                $output .= $this->generateModelInterface($modelClass);
            } catch (Exception $e) {
                $reflection = new ReflectionClass($modelClass);
                $modelName = $reflection->getShortName();
                $this->components->warn("Failed to generate type for {$modelName}");
                $this->components->bulletList([$e->getMessage()]);
            }
        }

        return $output;
    }

    private function generateModelInterface(string $modelClass): string
    {
        /** @var class-string $modelClass */
        $reflection = new ReflectionClass($modelClass);
        $modelName = $reflection->getShortName();

        // Skip if already processed
        if (in_array($modelName, $this->processedModels)) {
            return '';
        }

        $this->processedModels[] = $modelName;

        $output = "export interface {$modelName} {\n";

        /** @var Model $model */
        $model = new $modelClass;

        // Get table columns from migration
        $tableName = $model->getTable();
        $columns = $this->getTableColumns($tableName);

        // If no columns found, it might be using a custom table name - check variations
        if ($columns === []) {
            // Try singular form (e.g., client_billing_info instead of client_billing_infos)
            $singularTableName = mb_rtrim($tableName, 's');
            $columns = $this->getTableColumns($singularTableName);
        }

        // Get casts from model
        $casts = $model->getCasts();

        // Process each column
        foreach ($columns as $column) {
            $columnName = $column['name'];

            // Skip hidden attributes
            if (in_array($columnName, $model->getHidden())) {
                continue;
            }

            // Determine TypeScript type
            $type = $this->getTypeScriptType($column, $casts[$columnName] ?? null);

            // Handle nullable
            $nullable = $column['nullable'];
            $separator = $nullable ? '?' : '';

            $output .= "  {$columnName}{$separator}: {$type};\n";
        }

        // Add relationships
        $relationships = $this->getModelRelationships($modelClass);
        if ($relationships !== []) {
            $output .= "\n  // Relationships\n";
            foreach ($relationships as $relation) {
                $output .= "  {$relation['name']}?: {$relation['type']};\n";
            }
        }

        return $output."}\n\n";
    }

    private function loadMigrations(): void
    {
        $migrationPath = database_path('migrations');
        $files = File::files($migrationPath);

        foreach ($files as $file) {
            $content = File::get($file->getPathname());
            $this->parseMigration($content);
        }
    }

    private function parseMigration(string $content): void
    {
        // Extract Schema::create calls with better brace matching
        if (preg_match_all(
            '/Schema::create\([\'"](\w+)[\'"],\s*function\s*\([^)]*\)\s*{\s*(.*?)\s*}\s*\);/s',
            $content,
            $matches,
            PREG_SET_ORDER
        )) {
            foreach ($matches as $match) {
                $tableName = $match[1];
                $tableDefinition = $match[2];

                $this->migrationCache[$tableName] = $this->parseTableDefinition($tableDefinition);
            }
        }

        // Also handle Schema::table for modifications
        if (preg_match_all(
            '/Schema::table\([\'"](\w+)[\'"],\s*function\s*\([^)]*\)\s*{\s*(.*?)\s*}\s*\);/s',
            $content,
            $matches,
            PREG_SET_ORDER
        )) {
            foreach ($matches as $match) {
                $tableName = $match[1];
                $tableDefinition = $match[2];

                if (! isset($this->migrationCache[$tableName])) {
                    $this->migrationCache[$tableName] = [];
                }

                $newColumns = $this->parseTableDefinition($tableDefinition);
                foreach ($newColumns as $columnName => $columnData) {
                    $this->migrationCache[$tableName][$columnName] = $columnData;
                }
            }
        }
    }

    /**
     * @return array<string, array{name: string, type: string, nullable: bool}>
     */
    private function parseTableDefinition(string $definition): array
    {
        $columns = [];

        // Split by lines and process each line
        $lines = explode("\n", $definition);

        foreach ($lines as $line) {
            $line = mb_trim($line);
            // Skip empty lines and comments
            if ($line === '') {
                continue;
            }

            if ($line === '0') {
                continue;
            }

            if (str_starts_with($line, '//')) {
                continue;
            }

            // Match column definitions - better pattern
            if (! preg_match('/\$table->(\w+)\(/', $line, $typeMatch)) {
                continue;
            }

            $columnType = $typeMatch[1];

            // Handle special column types
            if ($columnType === 'timestamps') {
                $columns['created_at'] = [
                    'name' => 'created_at',
                    'type' => 'timestamp',
                    'nullable' => true,
                ];
                $columns['updated_at'] = [
                    'name' => 'updated_at',
                    'type' => 'timestamp',
                    'nullable' => true,
                ];

                continue;
            }

            if ($columnType === 'softDeletes') {
                $columns['deleted_at'] = [
                    'name' => 'deleted_at',
                    'type' => 'timestamp',
                    'nullable' => true,
                ];

                continue;
            }

            if ($columnType === 'rememberToken') {
                $columns['remember_token'] = [
                    'name' => 'remember_token',
                    'type' => 'string',
                    'nullable' => true,
                ];

                continue;
            }

            // Skip non-column methods
            if (in_array($columnType, ['primary', 'index', 'unique', 'foreign'])) {
                continue;
            }

            // Extract column name
            if (! preg_match('/\$table->'.$columnType.'\([\'"](\w+)[\'"]/', $line, $nameMatch)) {
                // Some methods like id() don't need a name parameter
                if ($columnType === 'id') {
                    $columnName = 'id';
                } elseif ($columnType === 'uuid' && ! str_contains($line, "('")) {
                    // uuid() without parameter - likely primary key
                    $columnName = 'id';
                } elseif ($columnType === 'foreignId' || $columnType === 'foreignUuid') {
                    // Try to extract from foreignId('user_id') or similar
                    if (preg_match('/\$table->'.$columnType.'\([\'"](\w+)[\'"]/', $line, $foreignMatch)) {
                        $columnName = $foreignMatch[1];
                    } else {
                        continue;
                    }
                } else {
                    continue;
                }
            } else {
                $columnName = $nameMatch[1];
            }

            // Check for nullable and default
            $nullable = str_contains($line, '->nullable()');
            $hasDefault = str_contains($line, '->default(');

            // Map foreignId and foreignUuid to appropriate types
            if ($columnType === 'foreignId') {
                $columnType = 'unsignedBigInteger';
            } elseif ($columnType === 'foreignUuid') {
                $columnType = 'uuid';
            }

            $columns[$columnName] = [
                'name' => $columnName,
                'type' => $columnType,
                'nullable' => $nullable || $hasDefault,
            ];
        }

        return $columns;
    }

    /**
     * @return array<string, array{name: string, type: string, nullable: bool}>
     */
    private function getTableColumns(string $tableName): array
    {
        return $this->migrationCache[$tableName] ?? [];
    }

    /**
     * @param  array{name: string, type: string, nullable: bool}  $column
     */
    private function getTypeScriptType(array $column, ?string $cast = null): string
    {
        // If there's a cast, use it
        if ($cast) {
            // Handle enum casts
            if (class_exists($cast) && enum_exists($cast)) {
                // Check if enum has cases
                $cases = $cast::cases();
                if (empty($cases)) {
                    // Empty enum, fall back to string
                    return 'string';
                }

                $reflection = new ReflectionClass($cast);
                $enumName = $reflection->getShortName();
                $namespace = str_replace(['App\\Enums\\', 'App\\Enums'], '', $reflection->getNamespaceName());

                return $namespace !== '' && $namespace !== '0' ? str_replace('\\', '', $namespace).$enumName : $enumName;
            }

            // Handle other casts
            return match ($cast) {
                'int', 'integer' => 'number',
                'real', 'float', 'double', 'decimal' => 'number',
                'bool', 'boolean' => 'boolean',
                'array', 'json' => 'any[]',
                'object' => 'Record<string, any>',
                'collection' => 'any[]',
                'datetime', 'date', 'timestamp', 'immutable_datetime', 'immutable_date' => 'string',
                'hashed' => 'string',
                default => 'string',
            };
        }

        // Otherwise use migration column type
        $columnType = $column['type'];

        return match ($columnType) {
            'id', 'bigInteger', 'integer', 'tinyInteger', 'smallInteger', 'mediumInteger', 'unsignedBigInteger', 'unsignedInteger', 'unsignedTinyInteger', 'unsignedSmallInteger', 'unsignedMediumInteger' => 'number',
            'float', 'double', 'decimal', 'unsignedDecimal' => 'number',
            'boolean' => 'boolean',
            'json', 'jsonb' => 'any[]',
            'timestamp', 'timestamps', 'timestampTz', 'timestampsTz', 'dateTime', 'dateTimeTz', 'date', 'time', 'timeTz', 'year' => 'string',
            'uuid' => 'string',
            'char', 'string', 'text', 'mediumText', 'longText', 'tinyText', 'binary' => 'string',
            'enum', 'set' => 'string',
            'ipAddress', 'macAddress' => 'string',
            'rememberToken' => 'string | null',
            'softDeletes', 'softDeletesTz' => 'string | null',
            default => 'string',
        };
    }

    /**
     * @return array<int, array{name: string, type: string}>
     */
    private function getModelRelationships(string $modelClass): array
    {
        $relationships = [];
        /** @var class-string $modelClass */
        $reflection = new ReflectionClass($modelClass);

        foreach ($reflection->getMethods(ReflectionMethod::IS_PUBLIC) as $method) {
            // Skip inherited methods from base classes
            if ($method->class !== $modelClass) {
                continue;
            }

            // Skip magic methods and constructors
            if (str_starts_with($method->name, '__')) {
                continue;
            }

            // Check if method has a return type that indicates a relationship
            $returnType = $method->getReturnType();
            if (! $returnType) {
                continue;
            }

            $returnTypeName = $returnType instanceof ReflectionNamedType ? $returnType->getName() : null;

            if (! $returnTypeName) {
                continue;
            }

            // Check if return type is a relation
            $relationType = $this->getRelationType($returnTypeName);
            if (! $relationType) {
                continue;
            }

            // Try to get the related model
            $relatedModel = $this->getRelatedModelFromMethod($modelClass, $method);

            if (! $relatedModel) {
                continue;
            }

            $relationships[] = [
                'name' => $method->name,
                'type' => $relationType['many'] ? "{$relatedModel}[]" : $relatedModel,
            ];
        }

        return $relationships;
    }

    /**
     * @return array{many: bool}|null
     */
    private function getRelationType(string $returnTypeName): ?array
    {
        return match ($returnTypeName) {
            HasOne::class, BelongsTo::class, MorphOne::class => ['many' => false],
            HasMany::class, BelongsToMany::class, MorphMany::class => ['many' => true],
            default => null,
        };
    }

    private function getRelatedModelFromMethod(string $modelClass, ReflectionMethod $method): ?string
    {
        try {
            // Instantiate model and call the method to get the relationship
            $model = new $modelClass;
            $relation = $method->invoke($model);

            if (! $relation) {
                return null;
            }

            $relatedClass = $relation->getRelated()::class;
            $reflection = new ReflectionClass($relatedClass);

            return $reflection->getShortName();
        } catch (Exception) {
            return null;
        }
    }

    /**
     * @return array<int, class-string>
     */
    private function getModels(string $path): array
    {
        $models = [];
        $files = File::allFiles($path);

        foreach ($files as $file) {
            // Get relative path and convert to namespace
            $relativePath = $file->getRelativePathname();
            $relativePath = str_replace('.php', '', $relativePath);
            $relativePath = str_replace(DIRECTORY_SEPARATOR, '\\', $relativePath);

            $class = 'App\\Models\\'.$relativePath;

            if (class_exists($class) && is_subclass_of($class, Model::class)) {
                $models[] = $class;
            }
        }

        return $models;
    }

    /**
     * @return array<int, class-string>
     */
    private function getEnums(string $path): array
    {
        $enums = [];

        if (! File::exists($path)) {
            return $enums;
        }

        $files = File::allFiles($path);

        foreach ($files as $file) {
            // Get relative path and convert to namespace
            $relativePath = $file->getRelativePathname();
            $relativePath = str_replace('.php', '', $relativePath);
            $relativePath = str_replace(DIRECTORY_SEPARATOR, '\\', $relativePath);

            $class = 'App\\Enums\\'.$relativePath;

            if (enum_exists($class)) {
                $enums[] = $class;
            }
        }

        return $enums;
    }

    /**
     * @param  array<int, class-string>  $models
     * @return array<int, string>
     */
    private function collectUsedEnums(array $models): array
    {
        $usedEnums = [];

        foreach ($models as $modelClass) {
            try {
                /** @var Model $model */
                $model = new $modelClass;
                $casts = $model->getCasts();

                foreach ($casts as $cast) {
                    if (class_exists($cast) && enum_exists($cast)) {
                        // Skip empty enums
                        $cases = $cast::cases();
                        if (empty($cases)) {
                            continue;
                        }

                        $reflection = new ReflectionClass($cast);
                        $enumName = $reflection->getShortName();
                        $namespace = str_replace(['App\\Enums\\', 'App\\Enums'], '', $reflection->getNamespaceName());
                        $fullName = $namespace !== '' && $namespace !== '0' ? str_replace('\\', '', $namespace).$enumName : $enumName;

                        if (! in_array($fullName, $usedEnums)) {
                            $usedEnums[] = $fullName;
                        }
                    }
                }
            } catch (Exception) {
                // Skip models that can't be instantiated
            }
        }

        sort($usedEnums);

        return $usedEnums;
    }

    private function getEnumBackingType(string $enumClass): string
    {
        /** @var class-string $enumClass */
        new ReflectionClass($enumClass);
        $cases = $enumClass::cases();

        if (empty($cases)) {
            return 'string';
        }

        $firstValue = $cases[0]->value;

        return is_int($firstValue) ? 'int' : 'string';
    }

    private function formatEnumValue(mixed $value, string $type): string
    {
        if ($type === 'int') {
            return (string) $value;
        }

        return "'".addslashes((string) $value)."'";
    }
}
